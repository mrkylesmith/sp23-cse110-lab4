1. The asynchronous nature of Javascript can make it diffcult for developers to debug and reason about the ordering of execution of their code.  Without the help of more advanced tooling, this asynchronous nature would make finding bugs more difficult then serial, in-order executed code.  Loose typing could be a pain point for a developer because of the implicit conversions we saw earlier in this lab, and because a variable could be reassigned to a different type, which could be used later in the program incorrectly.  With JavaScript, these loose typing errors could occur more easily during runtime in production, when a variable could be reassigned to an unexpected type, or misused in some way, which is in contrast to a strongly (or statically) typed language, which would put restrictions on how a type can be used, and these errors would be caught by the compiler.  I also think the web platform is particularly hard to program for several reasons.  Overall, both these first two reasons make it more difficult for a developer to track down and reason about bugs in their program.  The web platform integrates several languages and technologies into one programming interface that the developer must master.  Also to build an engaging website, the developer must think about actual users to build an engaging frontend interface, while also be concerned with the complexity of the backend, in order to ensure the correctness and performance of the application. The JavaScript web developer also deals with networks and data transfer latency as first-class concerns.

2. Since the web platform is user-facing and relies on several technolgies, I think JavaScript is loosely typed to enable the most flexibility for the language interpreter and runtime to execute programs without crashing, which would be a primary goal for any website.  I think the asynchronous features of JavaScript were created to enable better performance of the language while waiting for some piece of code to finish running.  In other words, since the web platform often relies on client-server architectures, a piece of JavaScript code might often have to wait for requests from the server.  By allowing JavaScript to run asynchronously, the JavaScript runtime can spend less time waiting for responses for the server and more time doing other useful work.

3. The key differences between a compiled language and interpreted language is a compiled language has strict typing and the compiler for the language will generate target assembly code.  An interpreted language such as JavaScript or Python has a runtime interpreter that is reasonable for running the code, no compilation is performed. I would say one of the benefits of having JavaScript be an interpreted language is portability, so that the language could be interpreted and run in any browser/computer.

4. The first order answer to this question is that you need to understand vanilla JavaScript first, before adding complexity and learning larger frameworks and libraries, that rely on vanilla JavaScript. Another reason, is that we should resist the tendency to reach for powerful, complex tools, when maybe that added complexity is not needed, and vanilla JavaScript will be more than sufficient to complete the project successfully.  It is probably a good idea to build a simple version of an app that works well first, and not add initial complexity to the app from the beginning, unless it is vital to the success of the project. The drawbacks of not learning a framework might be that it is currently a desired frontend skill in the industry. Also a specific library might considerably help with development, and thus the team should consider the tradeoffs of using this library.

5. There are several components of this lab that might be helpful to our course project, including basic JavaScript skills, debugging, and diagramming.  I previously had little knowledge of how to use the DevTools debugger and Network tab tools effectively, which I'm sure will be helpful when debugging our project app. Also the diagramming exercise actually took more time than I expected to create, but I can see that it would make the coding process much more approachable once you finish creating a diagram like that for a website.  It helps you create a mental model of the user's experience on your site. I think it would be very useful to create a user experience diagram like this for our project app, which is something we have already started creating in our group.